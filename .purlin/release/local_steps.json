{
    "steps": [
        {
            "id": "doc_consistency_framework",
            "friendly_name": "Framework Documentation Consistency",
            "description": "Verifies that Purlin instruction files are internally consistent with each other and with the framework's README. Purlin-specific: consumer projects do not own instruction files.",
            "code": null,
            "agent_instructions": "Cross-reference `instructions/HOW_WE_WORK_BASE.md`, `instructions/ARCHITECT_BASE.md`, `instructions/BUILDER_BASE.md`, `instructions/QA_BASE.md`, and `features/policy_critic.md`. Check for: direct contradictions between files, stale file path references, terminology mismatches, and lifecycle/protocol definitions that differ between the shared philosophy and role-specific instructions. Also verify that README.md is consistent with the current instruction file content. Fix any inconsistencies and commit."
        },
        {
            "id": "critic_consistency_check",
            "friendly_name": "Critic Consistency Check & README Update",
            "description": "Cross-references all Critic-related specification and instruction files for inconsistencies in terminology, routing rules, and responsibilities. Halts the release if critical inconsistencies are found. Once clean, writes or updates the '## The Critic' section in README.md.",
            "code": null,
            "agent_instructions": "1. AUDIT PHASE — Read all of the following files:\n   - features/critic_tool.md (what the Critic does; dual-gate spec)\n   - features/policy_critic.md (invariants and configuration policy)\n   - instructions/HOW_WE_WORK_BASE.md Section 8 (Critic-Driven Coordination)\n   - instructions/ARCHITECT_BASE.md (Critic startup mentions)\n   - instructions/BUILDER_BASE.md (Critic startup mentions)\n   - instructions/QA_BASE.md (Critic mandate sections)\n\n2. CHECK FOR INCONSISTENCIES:\n   - Terminology: Does every file use 'coordination engine' (not 'quality gate')? The term 'Critic Quality Gate' is deprecated; flag any occurrences.\n   - Routing rules: Are BUG/DISCOVERY/INTENT_DRIFT/SPEC_DISPUTE routing rules consistent across policy_critic.md, HOW_WE_WORK_BASE.md Section 7.5, and QA_BASE.md? Flag any divergence.\n   - Role status values: Are builder and QA status enumerations (DONE/FAIL/TODO/INFEASIBLE vs CLEAN/N/A/TODO/DISPUTED/FAIL) consistent across all files?\n   - Deprecated config: Is critic_gate_blocking described as a no-op everywhere it appears? Flag any file that still treats it as active.\n   - Startup mandate: Does every role instruction file mandate running tools/cdd/status.sh at session start? Flag any omissions.\n   - CLI-only contract: Does every file that mentions the agent interface specify CLI (never HTTP)? Flag any contradictions.\n\n3. REPORT: Present a table of findings (CRITICAL / WARNING / OK) for each check.\n   - CRITICAL inconsistencies: Halt. Do not proceed to README update. Report which files must be fixed before this step can complete.\n   - WARNING inconsistencies: Present to user. Proceed only if user confirms.\n   - All OK: Proceed to step 4.\n\n4. README UPDATE — Write or update the '## The Critic' section in README.md.\n   - Section placement: immediately after '## The Agents' section, before '## Setup & Configuration'.\n   - If the section already exists, diff against the current content and update only what has drifted; do not discard customized wording without confirmation.\n   - Content to write:\n     a. What the Critic is (coordination engine, not a badge)\n     b. Dual-gate validation (Spec Gate + Implementation Gate) — one sentence each\n     c. Supplementary audits — bulleted list (User Testing, Builder Decisions, Visual Spec, Untracked Files)\n     d. Role-specific action items — brief table or bulleted list\n     e. CDD vs. Critic (one-line contrast)\n     f. CLI invocation: tools/cdd/status.sh (auto-runs Critic), tools/critic/run.sh\n\n5. Commit README.md with message: 'docs(readme): update Role of the Critic section'."
        },
        {
            "id": "override_promotion_audit",
            "friendly_name": "Override-to-Base Promotion Audit",
            "description": "Audits `.purlin/` override files for instructions that are framework-level rules and should be promoted to base instruction files. Complements `purlin.instruction_audit` (which checks for contradictions) by catching rules that accidentally landed in overrides when they belong in the base layer. Purlin-specific: only meaningful in the framework repository where base files are editable.",
            "code": null,
            "agent_instructions": "1. READ ALL FOUR OVERRIDE/BASE PAIRS:\n   - .purlin/HOW_WE_WORK_OVERRIDES.md  ↔  instructions/HOW_WE_WORK_BASE.md\n   - .purlin/ARCHITECT_OVERRIDES.md     ↔  instructions/ARCHITECT_BASE.md\n   - .purlin/BUILDER_OVERRIDES.md       ↔  instructions/BUILDER_BASE.md\n   - .purlin/QA_OVERRIDES.md            ↔  instructions/QA_BASE.md\n\n2. EXTRACT AND NUMBER RULES: For each override file, identify every discrete\n   rule or section. Assign sequential numbers across ALL files (e.g.,\n   HOW_WE_WORK rules 1-3, ARCHITECT rules 4-7, BUILDER rules 8-9, etc.).\n\n3. CLASSIFY EACH RULE:\n   - PROMOTE: Universal contracts (submodule safety, agent behavior patterns,\n     tool interaction protocols) that apply to ALL Purlin consumer projects.\n   - PROMOTE: Rules about how agents handle submodule contexts in general.\n   - KEEP: Rules specific to THIS repository (dev/ folder conventions, sample\n     config sync prompts, framework documentation processes, Purlin CI/CD).\n   - KEEP: Rules referencing purlin-config-sample/, framework doc builds, or\n     dev/ scripts.\n\n4. PRESENT THE AUDIT TABLE grouped by override file:\n\n   | # | Override File | Rule Summary | Rec. | Rationale |\n   |---|---|---|---|---|\n\n   Ask: \"Which rules should be promoted? Enter numbers (e.g., 1,3,7) or\n   'none' to skip.\"\n\n5. FOR EACH APPROVED PROMOTION:\n   a. Read the target base file in full.\n   b. CONFLICT CHECK: Search for existing sections covering the same concern.\n      If found, present the overlap and ask: merge, replace, or skip.\n   c. If clean or user confirms: use /pl-edit-base to insert the promoted\n      content into the appropriate base file section.\n   d. After the base edit is committed, REMOVE the promoted rule from the\n      override file and commit.\n\n6. POST-PROMOTION VALIDATION: Run /pl-override-conflicts on each modified\n   override file. Removing a rule can unmask latent conflicts — catch them here.\n\n7. REPORT: If no promotions needed, report \"Override Promotion Audit: CLEAN —\n   all override rules are project-specific.\" If promotions occurred, report\n   summary: \"N rules promoted, M overrides modified, conflict check CLEAN.\""
        },
        {
            "id": "submodule_safety_audit",
            "friendly_name": "Purlin Submodule Safety Audit",
            "description": "Purlin-repository-specific pre-push audit that verifies all framework scripts, tools, and instruction files are safe for submodule deployment. Checks for known failure modes when tools/ lives inside a git submodule.",
            "code": null,
            "agent_instructions": "1. AUDIT SCOPE — Examine all Python tools under tools/ (critic.py, serve.py, and any other\n   .py files), all shell scripts under tools/ (status.sh, start.sh, run.sh, bootstrap.sh),\n   and base instruction files (instructions/*.md).\n\n2. CHECK 1 — PURLIN_PROJECT_ROOT env var (contract §2.11): Does each Python tool check\n   os.environ.get('PURLIN_PROJECT_ROOT') before path climbing? Does each shell script check\n   $PURLIN_PROJECT_ROOT before relative-path fallback? Do the launcher templates in\n   bootstrap.sh export PURLIN_PROJECT_ROOT? CRITICAL if any are missing.\n\n3. CHECK 2 — Climbing priority (contract §2.11): Do Python tools try the FURTHER path first\n   (../../../.purlin/config.json — submodule layout) BEFORE the nearer path\n   (../../.purlin/config.json — standalone layout) when PURLIN_PROJECT_ROOT is not set?\n   CRITICAL if nearer-first order is found.\n\n4. CHECK 3 — Artifact write locations (contract §2.12): Search for any writes to paths under\n   tools/ for .log, .pid, .json, or cache output. Permitted: .purlin/runtime/ and\n   .purlin/cache/. CRITICAL if tools/ writes are found.\n\n5. CHECK 4 — Config JSON safety (contract §2.13): Search Python tools for bare json.load()\n   or json.loads() on config files without try/except. WARNING if unguarded calls found.\n\n6. CHECK 5 — CWD-relative paths (contract §2.14): Search Python tools for bare os.getcwd()\n   or open('features/...') without a project root variable. Search shell scripts for bare\n   relative paths to project-level directories. CRITICAL if found.\n\n7. CHECK 6 — sed JSON safety (contract §2.10): Find all sed commands on .json files in shell\n   scripts. Verify each is followed by a python3 json.load validation step. Check the regex\n   does not risk stripping structural characters. CRITICAL if structural risk; WARNING if no\n   validation follows.\n\n8. CHECK 7 — Instruction file path awareness: Scan instruction files for direct 'tools/'\n   references lacking tools_root context. WARNING if unqualified reference found.\n\n9. REPORT — Output findings table (Category | File | Finding | Severity).\n   HALT if any CRITICAL. Confirm with user if any WARNING. Report CLEAN if all pass."
        }
    ]
}
