<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Software Map Viewer</title>
    <script src="https://cdn.jsdelivr.net/npm/cytoscape@3.30.4/dist/cytoscape.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dagre@0.8.5/dist/dagre.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cytoscape-dagre@2.5.0/cytoscape-dagre.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked@15.0.6/marked.min.js"></script>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: 'Menlo','Monaco','Consolas', monospace;
            background: #14191F; color: #B0B0B0;
            font-size: 12px; overflow: hidden;
            height: 100vh; display: flex; flex-direction: column;
        }
        .header {
            display: flex; align-items: center; gap: 12px;
            padding: 8px 12px; background: #1A2028;
            border-bottom: 1px solid #2A2F36; flex-shrink: 0;
        }
        .header h1 { font-size: 14px; color: #FFF; font-weight: 600; white-space: nowrap; }
        .search-box {
            margin-left: auto; display: flex; align-items: center; gap: 6px;
        }
        #search {
            background: #14191F; border: 1px solid #2A2F36; border-radius: 3px;
            color: #B0B0B0; padding: 4px 8px; font-size: 11px; width: 200px;
            font-family: inherit; outline: none;
        }
        #search:focus { border-color: #0288d1; }
        #search::placeholder { color: #555; }
        .search-hint { color: #555; font-size: 10px; }
        #cy { flex: 1; background: #14191F; }
        .modal-overlay {
            display: none; position: fixed; inset: 0;
            background: rgba(0,0,0,0.7); z-index: 1000;
            justify-content: center; align-items: center;
        }
        .modal-overlay.visible { display: flex; }
        .modal-content {
            background: #1A2028; border: 1px solid #2A2F36;
            border-radius: 6px; width: 700px; max-width: 90vw;
            max-height: 80vh; display: flex; flex-direction: column;
            position: relative;
        }
        .modal-header {
            display: flex; justify-content: space-between; align-items: center;
            padding: 10px 14px; border-bottom: 1px solid #2A2F36; flex-shrink: 0;
        }
        .modal-header h2 { font-size: 13px; color: #FFF; }
        .modal-close {
            background: none; border: 1px solid #444; color: #888;
            cursor: pointer; font-size: 14px; width: 24px; height: 24px;
            border-radius: 3px; display: flex; align-items: center;
            justify-content: center; line-height: 1;
        }
        .modal-close:hover { background: #333; color: #FFF; border-color: #666; }
        .modal-body {
            padding: 14px; overflow-y: auto; flex: 1;
            line-height: 1.6; color: #CCC;
        }
        .modal-body h1, .modal-body h2, .modal-body h3 { color: #FFF; margin: 12px 0 6px; }
        .modal-body h1 { font-size: 16px; }
        .modal-body h2 { font-size: 14px; }
        .modal-body h3 { font-size: 12px; }
        .modal-body p { margin: 6px 0; }
        .modal-body ul, .modal-body ol { margin: 6px 0 6px 20px; }
        .modal-body li { margin: 2px 0; }
        .modal-body code {
            background: #14191F; padding: 1px 4px; border-radius: 2px;
            font-size: 11px; color: #4FC3F7;
        }
        .modal-body pre {
            background: #14191F; padding: 8px; border-radius: 3px;
            overflow-x: auto; margin: 6px 0;
        }
        .modal-body pre code { padding: 0; background: none; }
        .modal-body blockquote {
            border-left: 3px solid #0288d1; padding-left: 10px;
            color: #888; margin: 6px 0;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Software Map</h1>
        <div class="search-box">
            <input type="text" id="search" placeholder="Filter nodes..." />
            <span class="search-hint">by label or filename</span>
        </div>
    </div>
    <div id="cy"></div>

    <div class="modal-overlay" id="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modal-title">Feature</h2>
                <button class="modal-close" id="modal-close" title="Close">X</button>
            </div>
            <div class="modal-body" id="modal-body"></div>
        </div>
    </div>


    <script>
        // -- State --
        let cy = null;
        let graphData = null;
        let isInitialLoad = true;
        let refreshTimer = null;

        // -- SVG Label Generator (dual-size typography with word wrapping) --
        const SVG_WIDTH = 200;
        const LABEL_FONT_SIZE = 14;
        const LABEL_LINE_HEIGHT = 18;
        const FILENAME_FONT_SIZE = 9;
        const FILENAME_LINE_HEIGHT = 14;
        // Monospace at font-size 14: ~8.4px per char; usable width ~190px
        const CHARS_PER_LINE = 22;

        function wrapText(text, maxChars) {
            const words = text.split(/\s+/);
            const lines = [];
            let currentLine = '';
            for (const word of words) {
                if (!currentLine) {
                    currentLine = word;
                } else if ((currentLine + ' ' + word).length <= maxChars) {
                    currentLine += ' ' + word;
                } else {
                    lines.push(currentLine);
                    currentLine = word;
                }
            }
            if (currentLine) lines.push(currentLine);
            return lines;
        }

        function createNodeLabelSVG(name, filename) {
            const esc = s => s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
            const nameLines = wrapText(name, CHARS_PER_LINE);
            const nameBlockHeight = nameLines.length * LABEL_LINE_HEIGHT;
            const totalHeight = nameBlockHeight + FILENAME_LINE_HEIGHT + 8;

            let tspans = '';
            nameLines.forEach((line, i) => {
                const y = LABEL_LINE_HEIGHT * (i + 1);
                tspans += '<tspan x="' + (SVG_WIDTH / 2) + '" dy="' + (i === 0 ? 0 : LABEL_LINE_HEIGHT) + '">' + esc(line) + '</tspan>';
            });

            const svg = '<svg xmlns="http://www.w3.org/2000/svg" width="' + SVG_WIDTH + '" height="' + totalHeight + '">' +
                '<text x="' + (SVG_WIDTH / 2) + '" y="' + LABEL_LINE_HEIGHT + '" text-anchor="middle" font-size="' + LABEL_FONT_SIZE + '" font-weight="bold" fill="#E8E8E8" font-family="Menlo,Monaco,Consolas,monospace">' + tspans + '</text>' +
                '<text x="' + (SVG_WIDTH / 2) + '" y="' + (nameBlockHeight + FILENAME_LINE_HEIGHT + 4) + '" text-anchor="middle" font-size="' + FILENAME_FONT_SIZE + '" fill="#888" font-family="Menlo,Monaco,Consolas,monospace">' + esc(filename) + '</text>' +
                '</svg>';
            return { url: 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svg), height: totalHeight };
        }

        // Category color palette
        const CATEGORY_COLORS = {
            'DevOps Tools': '#0288d1',
            'Auth': '#7B1FA2',
            'Core': '#2E7D32',
            'UI': '#7B1FA2',
            'Hardware': '#2E7D32',
            'Release': '#E65100',
            'Process': '#558B2F',
        };
        const DEFAULT_NODE_COLOR = '#01579b';

        // -- Initialization --
        async function init() {
            await loadGraph();
            startAutoRefresh();
        }

        async function loadGraph() {
            try {
                const resp = await fetch('dependency_graph.json?t=' + Date.now());
                if (!resp.ok) return;
                graphData = await resp.json();
                renderGraph();
            } catch (e) {
                console.error('Failed to load dependency graph:', e);
            }
        }

        function renderGraph() {
            if (!graphData || !graphData.features) return;

            const elements = buildCytoscapeElements(graphData.features);

            if (cy) {
                // Preserve viewport state before destroying
                const zoom = cy.zoom();
                const pan = cy.pan();
                cy.destroy();
                cy = createCytoscape(elements);
                if (!isInitialLoad) {
                    cy.zoom(zoom);
                    cy.pan(pan);
                } else {
                    cy.fit(undefined, 40);
                    isInitialLoad = false;
                }
            } else {
                cy = createCytoscape(elements);
                cy.fit(undefined, 40);
                isInitialLoad = false;
            }

            applySearchFilter();
        }

        function buildCytoscapeElements(features) {
            const nodes = [];
            const edges = [];
            const fileToId = {};
            const categories = new Set();

            // Build file-to-id map for edge resolution
            features.forEach(f => {
                const id = f.file.replace(/[^a-zA-Z0-9]/g, '_');
                fileToId[f.file] = id;
                // Also map just the filename for prerequisite matching
                const basename = f.file.split('/').pop();
                fileToId[basename] = id;
                categories.add(f.category);
            });

            // Create compound parent nodes for each category
            categories.forEach(cat => {
                const catId = 'cat_' + cat.replace(/[^a-zA-Z0-9]/g, '_');
                nodes.push({
                    data: {
                        id: catId,
                        label: cat,
                        isCategory: true,
                    }
                });
            });

            features.forEach(f => {
                const id = fileToId[f.file];
                const color = CATEGORY_COLORS[f.category] || DEFAULT_NODE_COLOR;
                const catId = 'cat_' + f.category.replace(/[^a-zA-Z0-9]/g, '_');
                const filename = f.file.split('/').pop();
                const svgResult = createNodeLabelSVG(f.label, filename);
                nodes.push({
                    data: {
                        id: id,
                        friendlyName: f.label,
                        filename: filename,
                        file: f.file,
                        category: f.category,
                        prerequisites: f.prerequisites || [],
                        color: color,
                        parent: catId,
                        svgLabel: svgResult.url,
                        nodeHeight: svgResult.height + 12,
                    }
                });

                (f.prerequisites || []).forEach(prereq => {
                    const sourceId = fileToId[prereq];
                    if (sourceId) {
                        edges.push({
                            data: {
                                id: 'e_' + sourceId + '_' + id,
                                source: sourceId,
                                target: id,
                            }
                        });
                    }
                });
            });

            return { nodes, edges };
        }

        function createCytoscape(elements) {
            const instance = cytoscape({
                container: document.getElementById('cy'),
                elements: [...elements.nodes, ...elements.edges],
                style: [
                    {
                        selector: 'node[!isCategory]',
                        style: {
                            'label': '',
                            'shape': 'round-rectangle',
                            'width': 220,
                            'height': 'data(nodeHeight)',
                            'background-color': 'data(color)',
                            'background-opacity': 0.15,
                            'background-image': 'data(svgLabel)',
                            'background-fit': 'contain',
                            'border-width': 2,
                            'border-color': 'data(color)',
                            'border-opacity': 0.6,
                        }
                    },
                    {
                        selector: '$node > node',
                        style: {
                            'label': 'data(label)',
                            'background-color': '#1A2028',
                            'background-opacity': 0.8,
                            'border-width': 1,
                            'border-color': '#2A2F36',
                            'border-style': 'dashed',
                            'color': '#666',
                            'font-size': '12px',
                            'font-weight': 'bold',
                            'text-valign': 'top',
                            'text-halign': 'center',
                            'text-margin-y': -8,
                            'padding': '24px',
                            'shape': 'round-rectangle',
                        }
                    },
                    {
                        selector: 'edge',
                        style: {
                            'width': 2,
                            'line-color': '#444',
                            'target-arrow-color': '#444',
                            'target-arrow-shape': 'triangle',
                            'curve-style': 'bezier',
                            'arrow-scale': 0.8,
                        }
                    },
                    {
                        selector: 'node.highlighted',
                        style: {
                            'border-color': '#FF7043',
                            'border-width': 3,
                            'border-opacity': 1,
                            'background-opacity': 0.3,
                            'z-index': 10,
                        }
                    },
                    {
                        selector: 'node.center-hover',
                        style: {
                            'border-color': '#4FC3F7',
                            'border-width': 3,
                            'border-opacity': 1,
                            'background-opacity': 0.35,
                            'z-index': 11,
                        }
                    },
                    {
                        selector: 'edge.highlighted',
                        style: {
                            'line-color': '#FF7043',
                            'target-arrow-color': '#FF7043',
                            'width': 3,
                            'z-index': 10,
                        }
                    },
                    {
                        selector: 'node.dimmed',
                        style: {
                            'opacity': 0.2,
                        }
                    },
                    {
                        selector: 'edge.dimmed',
                        style: {
                            'opacity': 0.1,
                        }
                    },
                    {
                        selector: 'node.search-hidden',
                        style: {
                            'opacity': 0.1,
                        }
                    },
                    {
                        selector: 'edge.search-hidden',
                        style: {
                            'opacity': 0.05,
                        }
                    },
                ],
                layout: {
                    name: 'dagre',
                    rankDir: 'TB',
                    nodeSep: 80,
                    rankSep: 100,
                    padding: 50,
                },
                wheelSensitivity: 0.3,
                minZoom: 0.1,
                maxZoom: 5,
            });

            // -- Hover highlighting (feature nodes only, not category parents) --
            instance.on('mouseover', 'node[!isCategory]', function(evt) {
                const node = evt.target;
                const neighborhood = node.neighborhood().add(node);

                instance.elements().addClass('dimmed');
                // Keep category parents visible
                instance.nodes('$node > node').removeClass('dimmed');
                neighborhood.removeClass('dimmed');

                node.addClass('center-hover');
                neighborhood.nodes().not(node).filter('[!isCategory]').addClass('highlighted');
                neighborhood.edges().addClass('highlighted');
            });

            instance.on('mouseout', 'node[!isCategory]', function() {
                instance.elements().removeClass('dimmed highlighted center-hover');
            });

            // -- Click for detail modal (feature nodes only) --
            instance.on('tap', 'node[!isCategory]', function(evt) {
                const file = evt.target.data('file');
                const label = evt.target.data('friendlyName');
                if (file) openModal(file, label);
            });

            return instance;
        }

        // -- Search/Filter --
        document.getElementById('search').addEventListener('input', function() {
            applySearchFilter();
        });

        function applySearchFilter() {
            if (!cy) return;
            const query = document.getElementById('search').value.trim().toLowerCase();

            if (!query) {
                cy.elements().removeClass('search-hidden');
                return;
            }

            cy.nodes().forEach(node => {
                const name = (node.data('friendlyName') || node.data('label') || '').toLowerCase();
                const file = (node.data('file') || '').toLowerCase();
                const filename = (node.data('filename') || '').toLowerCase();
                if (name.includes(query) || file.includes(query) || filename.includes(query)) {
                    node.removeClass('search-hidden');
                } else {
                    node.addClass('search-hidden');
                }
            });

            cy.edges().forEach(edge => {
                const src = edge.source();
                const tgt = edge.target();
                if (src.hasClass('search-hidden') && tgt.hasClass('search-hidden')) {
                    edge.addClass('search-hidden');
                } else {
                    edge.removeClass('search-hidden');
                }
            });
        }

        // -- Feature Detail Modal --
        async function openModal(filePath, label) {
            const overlay = document.getElementById('modal-overlay');
            const title = document.getElementById('modal-title');
            const body = document.getElementById('modal-body');

            title.textContent = label || filePath;
            body.innerHTML = '<p style="color:#666">Loading...</p>';
            overlay.classList.add('visible');

            try {
                const resp = await fetch('/feature?file=' + encodeURIComponent(filePath));
                if (!resp.ok) throw new Error('Failed to load feature file');
                const md = await resp.text();
                body.innerHTML = marked.parse(md);
            } catch (e) {
                body.innerHTML = '<p style="color:#FF4500">Could not load feature content.</p>';
            }
        }

        function closeModal() {
            document.getElementById('modal-overlay').classList.remove('visible');
        }

        document.getElementById('modal-close').addEventListener('click', closeModal);
        document.getElementById('modal-overlay').addEventListener('click', function(e) {
            if (e.target === this) closeModal();
        });
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') closeModal();
        });

        // -- Auto-refresh (preserves zoom/pan) --
        function startAutoRefresh() {
            refreshTimer = setInterval(async () => {
                await loadGraph();
            }, 5000);
        }

        // -- Start --
        init();
    </script>
</body>
</html>
