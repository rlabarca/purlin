# Implementation Notes: Critic Tool

*   **Tool Location:** `tools/critic/` directory containing `critic.py` (main engine), `traceability.py`, `policy_check.py`, `logic_drift.py`, `test_critic.py`, and `run.sh` (executable convenience wrapper).
*   **Test Output:** Test results go to `tests/critic_tool/tests.json`.
*   **LLM Cache:** Stored in `<project_root>/.purlin/cache/logic_drift_cache/` as JSON files keyed by hash pairs. Resolved via `_resolve_cache_dir(project_root)` in `logic_drift.py`, using the `project_root` parameter already passed to `run_logic_drift()`. Falls back to script-local `.cache/` only if `project_root` is not provided (defensive only — all callers pass it).
*   **No External Dependencies:** The deterministic components (Spec Gate, traceability, policy check) MUST NOT require any external packages beyond Python 3.9+ standard library. The LLM component requires the `anthropic` Python package only when enabled.
*   **[CLARIFICATION]** DEVIATION/DISCOVERY action items route to Architect (not Builder), as the spec says these require Architect acknowledgment. Builder's role is to get that acknowledgment, but the Critic generates the item for the Architect to act on. (Severity: INFO)
*   **Role Status Lifecycle Dependency:** `compute_role_status()` reads `feature_status.json` via `_get_feature_lifecycle_state()` for QA TODO conditions (a) and (b) -- both require TESTING state. FAIL, DISPUTED, CLEAN, and N/A are lifecycle-independent. If `feature_status.json` doesn't exist on disk, TESTING-based TODO detection is skipped for both conditions.
*   **QA CLEAN/N/A Signal:** QA CLEAN requires `tests/<feature>/tests.json` to exist with `status: "PASS"`. QA N/A means no tests.json exists. This makes QA status reflect actual test coverage: features with passing tests show CLEAN, features with no tests show N/A. Features with 0 manual scenarios but passing automated tests are CLEAN (not N/A).
*   **Critic Report Readability scenario removed:** SPEC_DISPUTE resolved -- manual readability scenario removed since CRITIC_REPORT.md is agent-facing. Verified 2026-02-20.
*   **[CLARIFICATION]** QA CLEAN computation restructured: pre-computes `testing_with_manual` flag then uses flat elif chain. This ensures TESTING + 0 manual scenarios falls through to CLEAN (not N/A), and TODO lifecycle with passing tests returns CLEAN (lifecycle-independent). Matches spec Sections 2.11 QA CLEAN/N/A definitions. (Severity: INFO)
*   **User Testing Discovery Parsing:** The original line-by-line parsing in `generate_action_items()` and `compute_role_status()` checked for `[TYPE]` tag and `OPEN` status on the same line. Real feature files use a heading-based format (`### [TYPE] Title` on one line, `- **Status:** OPEN` on a separate line), so the checks never matched. Fixed by adding `parse_discovery_entries()` -- a block-level parser that extracts type, title, and status from each discovery entry as a unit. All functions now pre-parse entries once and use structured lookups instead of line-by-line text matching. Test fixtures updated to use the real heading-based format.
*   **Builder FAIL vs TODO for open BUGs:** `compute_role_status()` incorrectly set builder=FAIL when `has_open_bugs` was True. Per spec Section 2.11, Builder FAIL is specifically "tests.json exists with status FAIL". Open BUGs generate Builder action items (TODO), not test failures (FAIL). Fixed by removing `has_open_bugs` from the FAIL condition — open BUGs now correctly flow through to TODO via the action items path.
*   **QA role_status FAIL for open BUGs:** BUG resolved 2026-02-20 — QA role_status was computed as TODO instead of FAIL when OPEN BUGs existed. Builder fixed the precedence logic and action item generation. Verified: QA column correctly shows FAIL on dashboard for features with open BUGs.
*   **SPEC_UPDATED-to-Builder action item routing (SUPERSEDED):** Previously, `generate_action_items()` checked SPEC_UPDATED entries for "Builder" in `action_required` and generated Builder items. This was redundant with lifecycle-based Builder signaling (spec edits reset the feature to TODO lifecycle, which gives Builder a TODO). Removed in the "QA Actionability" spec update. SPEC_UPDATED discoveries now only generate QA re-verify items when the feature is in TESTING lifecycle. The `Action Required` field is informational only.
*   **QA Actionability Principle (spec update 2026-02-20):** Three changes to QA role_status: (1) Removed condition (c) -- HAS_OPEN_ITEMS no longer triggers QA=TODO; OPEN items routing to other roles are not QA-actionable. (2) Made condition (b) lifecycle-dependent -- SPEC_UPDATED re-verify requires TESTING state. (3) Simplified CLEAN -- requires tests.json PASS, no longer requires user_testing==CLEAN. N/A is now a catch-all. This ensures at most one role shows TODO per discovery lifecycle step.
*   **QA Actionability Implementation (2026-02-20):** Implemented all three QA Actionability changes in `critic.py`: (1) Deleted SPEC_UPDATED-to-Builder action item routing block from `generate_action_items()`. (2) Made SPEC_UPDATED QA re-verify items conditional on TESTING lifecycle in both `generate_action_items()` and `compute_role_status()`. (3) Removed condition (c) and simplified CLEAN check in `compute_role_status()`. Also hoisted `lifecycle_state` computation in `generate_action_items()` to share between Builder and QA item generation. All 148 unit tests + lifecycle integration test pass.
*   **SPEC_UPDATED Builder routing discovery:** DISCOVERY resolved 2026-02-20 — spec updated to decouple SPEC_UPDATED discoveries from Builder action items. Builder signaling now comes exclusively from lifecycle state (TODO reset), not discovery routing. Verified working as designed.
*   **False-positive WARN elimination (spec update 2026-02-20):** Two Spec Gate checks produced WARNs for legitimate feature states: (1) scenario_classification flagged features with explicit "None" manual scenarios as "only one subsection" — updated PASS to accept explicit "None" declarations. (2) policy_anchoring flagged features with non-arch_*.md prerequisites as "not linked to policy file" — updated PASS to accept any valid prerequisite (feature is grounded via non-policy dependency). Also fixed scenario "Spec Gate No Prerequisite on Non-Policy" from FAIL to WARN to match the table definition. Added two new scenarios: "Spec Gate Non-Policy Prerequisite" (PASS) and "Scenario Classification Explicit None for Manual" (PASS).
*   **Visual Specification Detection (2026-02-21):** Implemented `parse_visual_spec()` — detects `## Visual Specification` sections, counts `### Screen:` subsections and `- [ ]`/`- [x]` checklist items. Output block added to `critic.json`. Visual items are inherently exempt from traceability since `parse_scenarios()` only extracts `#### Scenario:` headings. Separate visual QA action items generated for TESTING features with visual specs.
*   **Regression Scope Computation (2026-02-21):** Implemented `compute_regression_set()` with `_extract_scope_from_commit()` for `[Scope: ...]` trailer parsing and `_get_commit_changed_files()` for cross-validation. Supports full/targeted/cosmetic/dependency-only scopes. QA action items in `generate_action_items()` are now scope-aware with scope-specific descriptions. Cosmetic cross-validation warning emitted when commit modifies files despite cosmetic declaration.
*   **[CLARIFICATION]** `dependency-only` scope uses conservative default (all manual scenarios) rather than attempting prerequisite surface analysis. Proper cross-referencing with the dependency graph would require parsing the changed prerequisite's API surface, which is not yet specified. (Severity: INFO)
*   **Anchor Node Taxonomy Support (2026-02-21):** Updated `is_policy_file()` in `critic.py` to recognize all three anchor node prefixes (`arch_`, `design_`, `policy_`). Previously only `arch_` was recognized, causing `policy_*.md` files to fail the Spec Gate with "Missing sections: Overview, Requirements, Scenarios" instead of receiving the reduced evaluation (Purpose/Invariants only). Also updated `policy_check.py`: `discover_forbidden_patterns()` now scans all anchor node prefixes for FORBIDDEN patterns, and `get_feature_prerequisites()` now extracts all anchor node references (not just `arch_*`). Detail strings updated from "policy file" to "anchor node" per spec language (Section 2.1).
*   **CRITIC_RUNNING Recursion Guard (2026-02-22):** `run.sh` now exports `CRITIC_RUNNING=1` before calling `tools/cdd/status.sh`. This supports the auto-Critic integration in `status.sh` (cdd_status_monitor.md Section 2.6) — when `status.sh` auto-runs `run.sh`, and `run.sh` calls `status.sh` back to refresh `feature_status.json`, the inner `status.sh` sees `CRITIC_RUNNING` and skips the Critic step, preventing infinite recursion.
*   **Targeted Scope Name Validation (2026-02-21):** Implemented `policy_critic.md` Section 2.8 naming contract. `compute_regression_set()` now validates each name in a `targeted:` scope against the feature's `#### Scenario:` titles and `### Screen:` titles (via `Visual:` prefix). Unresolvable names produce WARNING entries in `cross_validation_warnings`. Also enhanced `parse_visual_spec()` to return `screen_names` list for name matching.

*   **LLM drift cache path fix (2026-02-22):** BUG resolved — `logic_drift.py` was writing `.cache/` inside `tools/critic/`, violating submodule safety §2.12. Fixed `CACHE_DIR` to use `PROJECT_ROOT/.purlin/cache/logic_drift_cache/` via standard §2.11 project root detection. CDD Dashboard Role Columns scenario verified PASS 2026-02-22.
*   **Title rename (2026-02-22):** Feature title changed from "Critic Quality Gate Tool" to "Critic Coordination Engine Tool". Cosmetic spec change only — no code impact. The tool's internal references already use "Critic" without qualifier.
*   **Targeted scope manual-scenario filter (2026-02-24):** DISCOVERY resolved — `generate_action_items()` targeted scope path now filters scenarios against `parse_scenarios()` to keep only manual scenarios. If zero manual scenarios remain after filtering, no QA action item is generated. This fixes the contradiction where `role_status.qa` was CLEAN but a QA action item was still emitted for automated-only targeted scopes.
