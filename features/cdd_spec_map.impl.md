# Implementation Notes: CDD Spec Map View

*   **Graph module location:** `tools/cdd/graph.py` — contains all graph generation logic ported from `tools/software_map/generate_tree.py`. Importable by `serve.py`.
*   **Companion file exclusion:** `parse_features()` in `graph.py` skips `*.impl.md` files. The filter checks `filename.endswith(".impl.md")` before the general `.endswith(".md")` check. This ensures only primary feature specs appear as graph nodes.
*   **Status messages to stderr:** All `print()` calls in `graph.py` use `file=sys.stderr` so that the `--cli-graph` mode can pipe clean JSON to stdout without interleaved status messages.
*   **Endpoints added to CDD serve.py:** `/dependency_graph.json` (serves cached JSON, 404 if missing), `/feature?file=<path>` (raw feature content, path traversal protection), `/impl-notes?file=<path>` (companion .impl.md content, 404 if none), `/config.json` (project config).
*   **File watcher:** Poll-based watcher using `os.scandir` mtime snapshots at 2-second intervals. Runs in a daemon thread. On change detection, calls `graph.run_full_generation()`. On generation failure, retains old snapshot so the next poll cycle retries.
*   **CLI modes:** `serve.py --cli-graph` regenerates and outputs dependency_graph.json to stdout. `status.sh --graph` is the shell wrapper.
*   **Server startup sequence:** (1) Run initial graph generation, (2) start file watcher thread, (3) start HTTP server. Initial generation failure is non-fatal (warning to stderr).
*   **Path traversal protection:** Both `/feature` and `/impl-notes` endpoints resolve paths via `os.path.normpath` and verify the result starts with the features directory. Returns 403 on violation.
*   **Dependency graph cache path:** `DEPENDENCY_GRAPH_PATH` constant in `serve.py` points to `.purlin/cache/dependency_graph.json`, consistent with `graph.py`'s output location.
*   **Test output:** Tests write to `tests/cdd_spec_map/tests.json` with `{"status": "PASS", ...}` format.
*   **Theme-Responsive Graph (2026-02-21):** `createNodeLabelSVG()` now accepts a `colors` parameter for SVG `fill` values instead of hardcoded `#E8E8E8`/`#888`. `buildCytoscapeElements()` passes `colors` through. `createCytoscape()` accepts `colors` and uses `c.surface`, `c.border`, `c.dim` for category parent bg, border, edge colors. `renderGraph()` calls `getThemeColors()` and passes colors through the chain. On `toggleTheme()`, `renderGraph()` is called to rebuild the entire Cytoscape instance with updated theme colors (preserving zoom/pan).
*   **Conditional Zoom/Pan Preservation (2026-02-23):** Replaced `isInitialLoad` flag with `userModifiedView` interaction tracking. Cytoscape `viewport` events set `userModifiedView = true` when not triggered programmatically (guarded by `programmaticViewport` flag). On auto-refresh: if `userModifiedView` is false, graph re-fits to viewport; if true, preserves zoom/pan. Switching to Spec Map view resets `userModifiedView = false` and calls `renderGraph()` to re-fit. "Recenter Graph" button (`recenterGraph()`) resets `userModifiedView = false` and calls `cy.fit()`, so subsequent auto-refresh cycles re-fit rather than preserve.
*   **Node Position Persistence (2026-02-23):** Tracks `userModifiedNodes` flag set by Cytoscape `dragfree` events on any node (feature or category). Positions saved to `localStorage` under a key derived from a DJB2 content hash of all node file:category pairs. On `renderGraph()`: computes content hash; if hash changed (node added/removed/recategorized), discards saved positions and resets `userModifiedNodes` (substantive change invalidation). If hash matches and user has moved nodes, restores saved positions after layout runs. `recenterGraph()` resets `userModifiedNodes`, clears localStorage, and re-runs dagre layout to reset all nodes to auto-layout positions.
*   **Inactivity Timeout (2026-02-23):** After 5 minutes of no user interaction (drag, pan, zoom, or tap), both `userModifiedView` and `userModifiedNodes` are reset, saved positions are cleared from localStorage, and the graph re-renders with packed layout and auto-fit. Timer is reset by viewport changes, node drags, and node taps. Timer is cleared when leaving the map view.
*   **Two-Level Category Packing Layout (2026-02-25):** Replaced single-pass dagre layout with a two-level approach. `runPackedLayout()` function: Level 1 runs dagre independently per category (TB direction, `nodeSep: 60`, `rankSep: 80`) on only intra-category edges, preserving hierarchical prerequisite flow within each group. Level 2 computes inter-category edge weights, sorts categories by total connectivity (most-connected first), then greedily places each category near the weighted centroid of its already-placed neighbors using `findNonOverlapping()` spiral search (step=50, gap=80px between category bounding boxes). `createCytoscape()` now uses `layout: { name: 'preset' }` instead of dagre — all node positioning is handled by `runPackedLayout()`. `recenterGraph()` and inactivity timeout both call `runPackedLayout()` instead of re-running global dagre. The `findNonOverlapping()` helper uses `centerY` parameter name (not `cy`) to avoid shadowing the global Cytoscape instance variable.
*   **Dynamic Category Label Sizing (2026-02-25):** Category group labels scale inversely with zoom: `LABEL_BASE_FONT / zoom` clamped to [12, 80]px in model coordinates. At zoom ~0.15 (typical fit-all), labels render at ~12 screen pixels; at zoom ≥1.0, labels stay at 12px model coords. Padding scales proportionally: `max(24, fontSize * 1.2)` to prevent label overlap with child nodes at low zoom. `text-margin-y` scales as `-(fontSize * 0.67)`. Updates are triggered via: (1) Cytoscape `zoom` event → rAF-debounced `scheduleUpdateCategoryLabels()`, (2) direct `updateCategoryLabelSizes()` calls after `runPackedLayout()`, after `cy.fit()`, and after recenter. State variable `labelSizeRaf` tracks the pending animation frame to prevent redundant updates.
