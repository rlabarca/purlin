# Feature: Purlin Submodule Safety Audit

> Label: "Release Step: Purlin Submodule Safety Audit"
> Category: "Release Process"
> Prerequisite: features/policy_release.md
> Prerequisite: features/release_checklist_core.md
> Prerequisite: features/submodule_bootstrap.md

## 1. Overview

This feature defines the `submodule_safety_audit` local release step: a Purlin-repository-specific
pre-push audit that verifies all framework scripts, tools, and instruction files are safe for
submodule deployment. The step checks for known failure modes when `tools/` lives inside a git
submodule — hardcoded path assumptions, missing environment variable checks, incorrect artifact
write locations, unsafe config parsing, and CWD-relative path dependencies.

This step is defined in Purlin's `.purlin/release/local_steps.json` and does not appear in
consumer project checklists. Consumer projects do not own Purlin's scripts or instruction files
and cannot perform this audit.

The canonical submodule safety contract is `features/submodule_bootstrap.md` Sections 2.10–2.14.
Each check category in this step corresponds to a section of that contract.

## 2. Requirements

### 2.1 Audit Scope

**Scripts:**
- All Python tools under `tools/` (e.g., `tools/critic/critic.py`, `tools/cdd/serve.py`)
- All shell scripts under `tools/` (e.g., `tools/cdd/status.sh`, `tools/cdd/start.sh`,
  `tools/critic/run.sh`, `tools/bootstrap.sh`, `tools/sync_upstream.sh`)

**Instruction Files:**
- `instructions/HOW_WE_WORK_BASE.md`
- `instructions/ARCHITECT_BASE.md`
- `instructions/BUILDER_BASE.md`
- `instructions/QA_BASE.md`

### 2.2 Check Categories

Seven check categories, each grounded in the submodule safety contract:

#### Category 1: PURLIN_PROJECT_ROOT Environment Variable Usage (Contract §2.11)

- Python tools MUST check `os.environ.get('PURLIN_PROJECT_ROOT')` before any path climbing.
  Using `os.getcwd()` or path climbing without first checking the env var is a **CRITICAL** finding.
- Shell scripts MUST check `$PURLIN_PROJECT_ROOT` before falling back to relative-path climbing.
  A script that assumes a fixed relative config path without checking the env var is **CRITICAL**.
- The `run_architect.sh`, `run_builder.sh`, and `run_qa.sh` launcher templates generated by
  `bootstrap.sh` MUST export `PURLIN_PROJECT_ROOT`. Absence is **CRITICAL**.

#### Category 2: Climbing Priority Reversal (Contract §2.11)

- Python tools that use directory climbing as fallback MUST check the FURTHER path first:
  `../../../.purlin/config.json` (submodule layout, 3 levels deep) before the nearer path
  `../../.purlin/config.json` (standalone layout, 2 levels deep).
- Nearer-first climbing order is **CRITICAL**: it will shadow the consumer project's config
  with the framework's own `.purlin/` in a submodule deployment.

#### Category 3: Artifact Write Locations (Contract §2.12)

- No tool MUST write log files, PID files, or data caches inside the `tools/` directory tree.
  Permitted destinations: `.purlin/runtime/` (logs, PIDs) and `.purlin/cache/` (generated data).
- Any write to a path under `tools/` for output data is **CRITICAL**.

#### Category 4: Config JSON Safety (Contract §2.13)

- All `json.load()` or `json.loads()` calls on config files in Python tools MUST be wrapped in
  `try/except` with a fallback default.
- An unguarded config JSON parse is a **WARNING**.

#### Category 5: CWD-Relative Path Assumptions (Contract §2.14)

- Python tools MUST NOT use `os.getcwd()` or bare relative path strings (e.g.,
  `open('features/', ...)`) without reference to a detected project root variable.
- Shell scripts MUST NOT use bare relative paths for project-level directories without
  deriving them from `$PURLIN_PROJECT_ROOT` or an equivalent detected root variable.
- A bare CWD-dependent path operation is **CRITICAL**.

#### Category 6: sed JSON Safety (Contract §2.10)

- Any `sed` command in a shell script operating on a `.json` file MUST:
  1. Use a regex that replaces only the target value, without stripping trailing commas,
     closing braces, or other structural characters.
  2. Be followed by a JSON validation step (e.g.,
     `python3 -c "import json; json.load(open('<path>'))"`).
- A `sed` regex that could strip structural JSON characters is **CRITICAL**.
- A `sed`-on-JSON without a subsequent validation step is a **WARNING**.

#### Category 7: Instruction File Path Reference Awareness

- Instruction files that reference `tools/` paths MUST include context indicating that the
  path resolves via `tools_root` from `.purlin/config.json`, not as a literal
  project-root-relative path.
- An unqualified `tools/` reference that lacks submodule-awareness context is a **WARNING**.

### 2.3 Report Output

The Architect produces a structured findings table per check category:

| Category | File | Finding | Severity |
|----------|------|---------|----------|

Severity levels:
- **CRITICAL** — Will break submodule deployments. The release MUST NOT proceed until resolved.
- **WARNING** — May cause issues in some submodule environments. User must explicitly confirm before proceeding.
- **PASS** — No issues detected.

### 2.4 Halt Conditions

- Any CRITICAL finding: halt the release. Report all critical items. Do not execute subsequent steps.
- Only WARNING findings: present to the user. Proceed only with explicit confirmation.
- All categories pass: report "Submodule Safety Audit: CLEAN" and proceed.

### 2.5 Remediation

Code fixes belong to the Builder. The Architect audits and reports; the Builder corrects the
identified file(s) and commits. The Architect then re-runs the audit to confirm resolution
before marking the step complete.

If a WARNING is user-confirmed as acceptable, the Architect adds an inline note in the
Implementation Notes of the relevant feature spec (colocated with the affected code's spec,
not this file).

### 2.6 Step Metadata

| Field | Value |
|-------|-------|
| ID | `submodule_safety_audit` |
| Friendly Name | `Purlin Submodule Safety Audit` |
| Scope | Purlin-local (not a global step) |
| Code | null |

**Agent Instructions (for `local_steps.json`):**

```
1. AUDIT SCOPE — Examine all Python tools under tools/ (critic.py, serve.py, and any other
   .py files), all shell scripts under tools/ (status.sh, start.sh, run.sh, bootstrap.sh,
   sync_upstream.sh), and base instruction files (instructions/*.md).

2. CHECK 1 — PURLIN_PROJECT_ROOT env var (contract §2.11): Does each Python tool check
   os.environ.get('PURLIN_PROJECT_ROOT') before path climbing? Does each shell script check
   $PURLIN_PROJECT_ROOT before relative-path fallback? Do the launcher templates in
   bootstrap.sh export PURLIN_PROJECT_ROOT? CRITICAL if any are missing.

3. CHECK 2 — Climbing priority (contract §2.11): Do Python tools try the FURTHER path first
   (../../../.purlin/config.json — submodule layout) BEFORE the nearer path
   (../../.purlin/config.json — standalone layout) when PURLIN_PROJECT_ROOT is not set?
   CRITICAL if nearer-first order is found.

4. CHECK 3 — Artifact write locations (contract §2.12): Search for any writes to paths under
   tools/ for .log, .pid, .json, or cache output. Permitted: .purlin/runtime/ and
   .purlin/cache/. CRITICAL if tools/ writes are found.

5. CHECK 4 — Config JSON safety (contract §2.13): Search Python tools for bare json.load()
   or json.loads() on config files without try/except. WARNING if unguarded calls found.

6. CHECK 5 — CWD-relative paths (contract §2.14): Search Python tools for bare os.getcwd()
   or open('features/...') without a project root variable. Search shell scripts for bare
   relative paths to project-level directories. CRITICAL if found.

7. CHECK 6 — sed JSON safety (contract §2.10): Find all sed commands on .json files in shell
   scripts. Verify each is followed by a python3 json.load validation step. Check the regex
   does not risk stripping structural characters. CRITICAL if structural risk; WARNING if no
   validation follows.

8. CHECK 7 — Instruction file path awareness: Scan instruction files for direct 'tools/'
   references lacking tools_root context. WARNING if unqualified reference found.

9. REPORT — Output findings table (Category | File | Finding | Severity).
   HALT if any CRITICAL. Confirm with user if any WARNING. Report CLEAN if all pass.
```

## 3. Scenarios

### Automated Scenarios
None. All verification is manual (Architect-executed release step).

### Manual Scenarios (Architect Execution)

#### Scenario: Clean audit — all checks pass
Given all Python tools, shell scripts, and instruction files comply with the submodule safety contract,
When the Architect executes the `submodule_safety_audit` step,
Then the Architect reports "Submodule Safety Audit: CLEAN — all 7 check categories passed."
And no commits are made.

#### Scenario: CRITICAL finding — missing PURLIN_PROJECT_ROOT check in Python tool
Given a Python tool performs directory climbing without first checking os.environ.get('PURLIN_PROJECT_ROOT'),
When the Architect executes the `submodule_safety_audit` step,
Then the Architect identifies the specific tool file and line,
And reports a CRITICAL finding in Check Category 1,
And halts the release without executing subsequent steps.

#### Scenario: CRITICAL finding — reversed climbing priority
Given a Python tool checks ../../.purlin/config.json (nearer path) before ../../../.purlin/config.json,
When the Architect executes the `submodule_safety_audit` step,
Then the Architect identifies the specific tool and the incorrect path order,
And reports a CRITICAL finding in Check Category 2,
And halts the release.

#### Scenario: CRITICAL finding — artifact written inside tools/
Given a script writes a .pid or .log file to a path inside the tools/ directory tree,
When the Architect executes the `submodule_safety_audit` step,
Then the Architect identifies the specific script and write target,
And reports a CRITICAL finding in Check Category 3,
And halts the release.

#### Scenario: WARNING finding — unguarded json.load confirmed by user
Given a Python tool calls json.load() on a config file without a try/except block,
When the Architect executes the `submodule_safety_audit` step,
Then the Architect identifies the file and line number and reports a WARNING in Check Category 4,
And presents the warning to the user for explicit confirmation,
And if the user confirms, the Architect records the known limitation in the affected feature's
Implementation Notes and proceeds to the next release step.

## Implementation Notes

This feature has no automated test coverage. Verification is performed by the Architect
during the release process per the scenarios above. The QA column will always be `N/A`.

The seven check categories map directly to `features/submodule_bootstrap.md` Sections 2.10–2.14
(Categories 1–6) and the Submodule Compatibility Mandate in `HOW_WE_WORK_OVERRIDES.md`
(Category 7). When new submodule safety requirements are added to `submodule_bootstrap.md`,
this feature spec MUST be updated to add a corresponding check category.

Remediation ownership: the Architect audits and halts; the Builder fixes code. The Architect
does not modify tool scripts — all code corrections go to the Builder via the spec. The audit
findings themselves serve as the Builder's action items once this feature is in TESTING state.
